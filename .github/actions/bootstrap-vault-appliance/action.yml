name: bootstrap-vault-appliance
description: >-
  Initialise or verify the DigitalOcean Vault appliance using the repository's
  Python bootstrap helper. The action is idempotent: re-runs verify the existing
  appliance instead of recreating it.
author: Wildside platform team
branding:
  icon: lock
  color: blue

inputs:
  environment:
    description: Logical environment identifier (e.g. dev, staging, preview).
    required: true
  vault_address:
    description: Fully qualified Vault HTTPS endpoint exposed by the load balancer.
    required: true
  droplet_tag:
    description: >-
      DigitalOcean tag applied to Vault droplets. Defaults to "vault-<environment>"
      when omitted.
    required: false
  digitalocean_token:
    description: DigitalOcean API token with read access to the droplet tag.
    required: true
    secret: true
  ca_certificate:
    description: >-
      PEM-encoded CA certificate used to validate the Vault endpoint. Accepts raw
      PEM text or base64-encoded content. Optional when Vault serves a public
      certificate.
    required: false
  bootstrap_state:
    description: >-
      JSON or base64-encoded JSON payload for the bootstrap state file
      (unseal_keys, root_token, approle_role_id, approle_secret_id). When not
      provided, the helper will initialise Vault and capture new state.
    required: false
  state_path:
    description: >-
      Optional override for where the bootstrap state file is written. Defaults to
      $RUNNER_TEMP/vault-bootstrap/<environment>/state.json.
    required: false
  ssh_user:
    description: SSH user used to probe the Vault service on each droplet.
    required: false
    default: root
  ssh_private_key:
    description: >-
      Optional SSH private key for the droplet health checks. When provided, it is
      written to a temporary file with 0600 permissions and passed via
      --ssh-identity.
    required: false
    secret: true
  kv_mount_path:
    description: Mount path for the KV v2 secrets engine.
    required: false
    default: secret
  approle_name:
    description: Name of the AppRole provisioned for the DOKS workflow.
    required: false
    default: doks-deployer
  approle_policy_name:
    description: Vault policy name attached to the AppRole.
    required: false
    default: doks-deployer
  approle_policy:
    description: Optional HCL policy content overriding the default KV policy.
    required: false
  token_ttl:
    description: TTL applied to tokens issued via the AppRole.
    required: false
    default: 1h
  token_max_ttl:
    description: Maximum TTL for AppRole tokens.
    required: false
    default: 4h
  secret_id_ttl:
    description: TTL for generated AppRole secret IDs.
    required: false
    default: 4h
  rotate_secret_id:
    description: >-
      Set to true to force rotation of the AppRole secret ID even when one is
      already recorded in the state file.
    required: false
    default: "false"
  key_shares:
    description: Number of unseal key shares generated during initialisation.
    required: false
    default: "5"
  key_threshold:
    description: Number of shares required to unseal Vault.
    required: false
    default: "3"
  vault_cli_version:
    description: Version of the Vault CLI to install (e.g. 1.17.6).
    required: false
    default: 1.17.6

outputs:
  vault-address:
    description: Vault endpoint used for the bootstrap run.
    value: ${{ steps.publish.outputs.vault-address }}
  ca-certificate-path:
    description: Path to the CA certificate written for this run (empty if omitted).
    value: ${{ steps.publish.outputs.ca-certificate-path }}
  state-file:
    description: Path to the bootstrap state file captured on the runner.
    value: ${{ steps.publish.outputs.state-file }}
  approle-role-id:
    description: AppRole role_id resolved during bootstrap.
    value: ${{ steps.publish.outputs.approle-role-id }}
  approle-secret-id:
    description: AppRole secret_id resolved or rotated during bootstrap.
    value: ${{ steps.publish.outputs.approle-secret-id }}

runs:
  using: composite
  steps:
    - name: Compute paths and seed bootstrap state
      id: seed
      shell: bash
      env:
        INPUT_BOOTSTRAP_STATE: ${{ inputs.bootstrap_state }}
        INPUT_CA_CERTIFICATE: ${{ inputs.ca_certificate }}
        INPUT_SSH_KEY: ${{ inputs.ssh_private_key }}
        INPUT_STATE_PATH: ${{ inputs.state_path }}
        INPUT_ENVIRONMENT: ${{ inputs.environment }}
      run: |
        set -euo pipefail

        ENVIRONMENT="${INPUT_ENVIRONMENT}"
        DROPLET_TAG="${{ inputs.droplet_tag }}"
        if [ -z "${DROPLET_TAG}" ]; then
          DROPLET_TAG="vault-${ENVIRONMENT}"
        fi

        STATE_FILE="${INPUT_STATE_PATH:-${RUNNER_TEMP}/vault-bootstrap/${ENVIRONMENT}/state.json}"
        mkdir -p "$(dirname "${STATE_FILE}")"

        write_payload_file() {
          local payload="$1" path="$2"
          if [ -z "${payload}" ]; then
            return 0
          fi

          python -c "import base64,binascii,json,pathlib,sys,textwrap; code = textwrap.dedent('''\
        payload = sys.argv[1]
        path = pathlib.Path(sys.argv[2])
        candidate = payload
        if not candidate.strip():
            sys.exit(0)
        try:
            decoded = base64.b64decode(candidate, validate=True)
            candidate = decoded.decode('utf-8')
        except (binascii.Error, UnicodeDecodeError):
            candidate = payload
        if path.suffix == '.json':
            try:
                parsed = json.loads(candidate)
            except json.JSONDecodeError as exc:
                raise SystemExit(f'Invalid JSON supplied for {path.name}: {exc}')
            candidate = json.dumps(parsed, indent=2)
        path.write_text(candidate, encoding='utf-8')
        path.chmod(0o600)
        '''); exec(code)" "${payload}" "${path}"
        }

        if [ ! -f "${STATE_FILE}" ] && [ -n "${INPUT_BOOTSTRAP_STATE}" ]; then
          write_payload_file "${INPUT_BOOTSTRAP_STATE}" "${STATE_FILE}"
        fi

        CA_CERT_PATH=""
        if [ -n "${INPUT_CA_CERTIFICATE}" ]; then
          CA_CERT_PATH="$(dirname "${STATE_FILE}")/vault-ca.pem"
          write_payload_file "${INPUT_CA_CERTIFICATE}" "${CA_CERT_PATH}"
        fi

        SSH_IDENTITY=""
        if [ -n "${INPUT_SSH_KEY}" ]; then
          SSH_IDENTITY="$(dirname "${STATE_FILE}")/vault-ssh-key"
          umask 077
          printf "%s\n" "${INPUT_SSH_KEY}" >"${SSH_IDENTITY}"
          chmod 600 "${SSH_IDENTITY}"
          echo "::add-mask::${INPUT_SSH_KEY}"
        fi

        echo "DROPLET_TAG=${DROPLET_TAG}" >>"${GITHUB_ENV}"
        echo "STATE_FILE=${STATE_FILE}" >>"${GITHUB_ENV}"
        if [ -n "${CA_CERT_PATH}" ]; then
          echo "CA_CERT_PATH=${CA_CERT_PATH}" >>"${GITHUB_ENV}"
        fi
        if [ -n "${SSH_IDENTITY}" ]; then
          echo "SSH_IDENTITY=${SSH_IDENTITY}" >>"${GITHUB_ENV}"
        fi

    - name: Install uv
      uses: astral-sh/setup-uv@557e51de59eb14aaaba2ed9621916900a91d50c6

    - name: Install doctl
      uses: digitalocean/action-doctl@135ac0aa0eed4437d547c6f12c364d3006b42824
      with:
        token: ${{ inputs.digitalocean_token }}

    - name: Install Vault CLI
      shell: bash
      env:
        VAULT_VERSION: ${{ inputs.vault_cli_version }}
      run: |
        set -euo pipefail
        if command -v vault >/dev/null 2>&1; then
          exit 0
        fi
        ARCHIVE="vault_${VAULT_VERSION}_linux_amd64.zip"
        BASE_URL="https://releases.hashicorp.com/vault/${VAULT_VERSION}"
        curl -fsSLo /tmp/vault.zip "${BASE_URL}/${ARCHIVE}"
        curl -fsSLo /tmp/vault_SHA256SUMS "${BASE_URL}/vault_${VAULT_VERSION}_SHA256SUMS"
        grep "${ARCHIVE}" /tmp/vault_SHA256SUMS > /tmp/vault_SHA256SUMS_filtered
        (cd /tmp && sha256sum -c vault_SHA256SUMS_filtered)
        mkdir -p "${RUNNER_TEMP}/bin"
        unzip -qo /tmp/vault.zip -d "${RUNNER_TEMP}/bin"
        echo "${RUNNER_TEMP}/bin" >>"${GITHUB_PATH}"

    - name: Bootstrap Vault appliance
      shell: bash
      env:
        DIGITALOCEAN_ACCESS_TOKEN: ${{ inputs.digitalocean_token }}
        VAULT_ADDRESS: ${{ inputs.vault_address }}
        UV_CACHE_DIR: ${{ runner.temp }}/uv-cache
      run: |
        set -euo pipefail

        args=(
          --vault-addr "${VAULT_ADDRESS}"
          --droplet-tag "${DROPLET_TAG}"
          --state-file "${STATE_FILE}"
          --ssh-user "${{ inputs.ssh_user }}"
          --kv-mount-path "${{ inputs.kv_mount_path }}"
          --approle-name "${{ inputs.approle_name }}"
          --approle-policy-name "${{ inputs.approle_policy_name }}"
          --token-ttl "${{ inputs.token_ttl }}"
          --token-max-ttl "${{ inputs.token_max_ttl }}"
          --secret-id-ttl "${{ inputs.secret_id_ttl }}"
          --key-shares "${{ inputs.key_shares }}"
          --key-threshold "${{ inputs.key_threshold }}"
        )

        if [ -n "${SSH_IDENTITY:-}" ]; then
          args+=(--ssh-identity "${SSH_IDENTITY}")
        fi
        if [ -n "${CA_CERT_PATH:-}" ]; then
          args+=(--ca-certificate "${CA_CERT_PATH}")
        fi

        if [ -n "${{ inputs.approle_policy }}" ]; then
          POLICY_PATH="$(dirname "${STATE_FILE}")/approle-policy.hcl"
          printf "%s\n" "${{ inputs.approle_policy }}" >"${POLICY_PATH}"
          args+=(--approle-policy-path "${POLICY_PATH}")
        fi

        if [ "${{ inputs.rotate_secret_id }}" = "true" ]; then
          args+=(--rotate-secret-id)
        fi

        uv run scripts/bootstrap_vault_appliance.py "${args[@]}"

    - name: Publish bootstrap outputs
      id: publish
      shell: bash
      env:
        STATE_FILE: ${{ env.STATE_FILE }}
        VAULT_ADDRESS: ${{ inputs.vault_address }}
        CA_CERT_PATH: ${{ env.CA_CERT_PATH }}
      run: |
        set -euo pipefail

        python -c "import json, os, textwrap; from pathlib import Path; code = textwrap.dedent('''\
        state_path = Path(os.environ['STATE_FILE'])
        out_path = Path(os.environ['GITHUB_OUTPUT'])
        state = json.loads(state_path.read_text(encoding='utf-8'))

        approle_role_id = state.get('approle_role_id') or ''
        approle_secret_id = state.get('approle_secret_id') or ''
        root_token = state.get('root_token') or ''
        unseal_keys = state.get('unseal_keys') or []

        for secret in [approle_secret_id, root_token, *unseal_keys]:
            if secret:
                print(f\"::add-mask::{secret}\")

        with out_path.open('a', encoding='utf-8') as handle:
            handle.write(f\"vault-address={os.environ['VAULT_ADDRESS']}\\n\")
            handle.write(f\"state-file={state_path}\\n\")
            handle.write(f\"approle-role-id={approle_role_id}\\n\")
            handle.write(f\"approle-secret-id={approle_secret_id}\\n\")
            handle.write(f\"ca-certificate-path={os.environ.get('CA_CERT_PATH', '')}\\n\")
        '''); exec(code)"
