//! PostgreSQL-backed `UserRepository` implementation using Diesel ORM.
//!
//! This adapter implements the domain's `UserRepository` port, translating
//! between domain `User` entities and Diesel row structs. All database
//! operations are async via `diesel-async`.
//!
//! # Error Handling
//!
//! All Diesel and pool errors are mapped to the domain's `UserPersistenceError`
//! variants using the constructor helpers generated by `define_port_error!`.

use async_trait::async_trait;
use diesel::prelude::*;
use diesel::upsert::excluded;
use diesel_async::RunQueryDsl;
use tracing::debug;

use crate::domain::ports::{UserPersistenceError, UserRepository};
use crate::domain::{DisplayName, User, UserId};

use super::models::{NewUserRow, UserRow};
use super::pool::{DbPool, PoolError};
use super::schema::users;

/// Diesel-backed implementation of the `UserRepository` port.
///
/// This adapter provides PostgreSQL persistence for `User` entities using
/// Diesel ORM with async support. It requires a configured `DbPool` for
/// connection management.
///
/// # Example
///
/// ```ignore
/// let pool = DbPool::new(config).await?;
/// let repo = DieselUserRepository::new(pool);
///
/// let user = User::try_from_strings("uuid-here", "Display Name")?;
/// repo.upsert(&user).await?;
/// ```
#[derive(Clone)]
pub struct DieselUserRepository {
    pool: DbPool,
}

impl DieselUserRepository {
    /// Create a new repository with the given connection pool.
    pub fn new(pool: DbPool) -> Self {
        Self { pool }
    }
}

/// Map pool errors to domain persistence errors.
fn map_pool_error(error: PoolError) -> UserPersistenceError {
    match error {
        PoolError::Checkout { message } | PoolError::Build { message } => {
            UserPersistenceError::connection(message)
        }
    }
}

/// Map Diesel errors to domain persistence errors.
fn map_diesel_error(error: diesel::result::Error) -> UserPersistenceError {
    use diesel::result::{DatabaseErrorKind, Error as DieselError};

    match &error {
        DieselError::DatabaseError(kind, info) => {
            debug!(?kind, message = info.message(), "diesel operation failed");
        }
        _ => debug!(
            error_type = %std::any::type_name_of_val(&error),
            "diesel operation failed"
        ),
    }

    match error {
        DieselError::NotFound => UserPersistenceError::query("record not found"),
        DieselError::QueryBuilderError(_) => UserPersistenceError::query("database query error"),
        DieselError::DatabaseError(kind, _) => match kind {
            DatabaseErrorKind::UniqueViolation => {
                UserPersistenceError::query("unique constraint violation")
            }
            DatabaseErrorKind::ForeignKeyViolation => {
                UserPersistenceError::query("foreign key violation")
            }
            DatabaseErrorKind::NotNullViolation => {
                UserPersistenceError::query("not null violation")
            }
            DatabaseErrorKind::CheckViolation => {
                UserPersistenceError::query("check constraint violation")
            }
            DatabaseErrorKind::SerializationFailure => {
                UserPersistenceError::query("serialization failure")
            }
            DatabaseErrorKind::ReadOnlyTransaction => {
                UserPersistenceError::query("read-only transaction")
            }
            DatabaseErrorKind::ClosedConnection => {
                UserPersistenceError::connection("database connection error")
            }
            _ => UserPersistenceError::query("database error"),
        },
        _ => UserPersistenceError::query("database error"),
    }
}

/// Convert a database row to a domain User.
///
/// # Errors
///
/// Returns `UserPersistenceError::Query` if the row data fails domain validation
/// (e.g., display name constraints).
fn row_to_user(row: UserRow) -> Result<User, UserPersistenceError> {
    let user_id = UserId::from_uuid(row.id);
    let display_name = DisplayName::new(row.display_name).map_err(|err| {
        debug!(?err, "invalid display name loaded from database");
        UserPersistenceError::query("invalid user record")
    })?;
    Ok(User::new(user_id, display_name))
}

#[async_trait]
impl UserRepository for DieselUserRepository {
    async fn upsert(&self, user: &User) -> Result<(), UserPersistenceError> {
        let mut conn = self.pool.get().await.map_err(map_pool_error)?;

        let new_user = NewUserRow {
            id: *user.id().as_uuid(),
            display_name: user.display_name().as_ref(),
        };

        diesel::insert_into(users::table)
            .values(&new_user)
            .on_conflict(users::id)
            .do_update()
            .set(users::display_name.eq(excluded(users::display_name)))
            .execute(&mut conn)
            .await
            .map(|_| ())
            .map_err(map_diesel_error)
    }

    async fn find_by_id(&self, id: &UserId) -> Result<Option<User>, UserPersistenceError> {
        let mut conn = self.pool.get().await.map_err(map_pool_error)?;

        let result: Option<UserRow> = users::table
            .filter(users::id.eq(id.as_uuid()))
            .select(UserRow::as_select())
            .first(&mut conn)
            .await
            .optional()
            .map_err(map_diesel_error)?;

        match result {
            Some(row) => row_to_user(row).map(Some),
            None => Ok(None),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rstest::{fixture, rstest};

    #[fixture]
    fn sample_user_id() -> UserId {
        UserId::new("11111111-1111-1111-1111-111111111111").expect("valid fixture UUID")
    }

    #[fixture]
    fn sample_display_name() -> DisplayName {
        DisplayName::new("Test User").expect("valid fixture display name")
    }

    #[fixture]
    fn sample_user(sample_user_id: UserId, sample_display_name: DisplayName) -> User {
        User::new(sample_user_id, sample_display_name)
    }

    #[rstest]
    fn pool_error_maps_to_connection_error() {
        let pool_err = PoolError::checkout("connection refused");
        let persistence_err = map_pool_error(pool_err);

        assert!(matches!(
            persistence_err,
            UserPersistenceError::Connection { .. }
        ));
        assert!(
            persistence_err.to_string().contains("connection refused"),
            "preserve useful diagnostics"
        );
    }

    #[rstest]
    fn diesel_error_maps_to_query_error() {
        let diesel_err = diesel::result::Error::NotFound;
        let persistence_err = map_diesel_error(diesel_err);

        assert!(matches!(
            persistence_err,
            UserPersistenceError::Query { .. }
        ));
        assert!(
            persistence_err.to_string().contains("record not found"),
            "preserve stable, user-facing diagnostics"
        );
    }
}
