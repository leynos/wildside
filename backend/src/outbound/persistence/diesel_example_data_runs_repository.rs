//! PostgreSQL-backed `ExampleDataRunsRepository` implementation using Diesel ORM.
//!
//! This adapter implements the domain's `ExampleDataRunsRepository` port,
//! providing once-only seeding semantics via `INSERT ... ON CONFLICT DO NOTHING`.
//! All database operations are async via `diesel-async`.
//!
//! # Error Handling
//!
//! All Diesel and pool errors are mapped to the domain's `ExampleDataRunsError`
//! variants using the constructor helpers generated by `define_port_error!`.

use async_trait::async_trait;
use diesel::prelude::*;
use diesel_async::RunQueryDsl;
use tracing::debug;

use crate::domain::ports::{ExampleDataRunsError, ExampleDataRunsRepository, SeedingResult};

use super::models::NewExampleDataRunRow;
use super::pool::{DbPool, PoolError};
use super::schema::example_data_runs;

/// Diesel-backed implementation of the `ExampleDataRunsRepository` port.
///
/// This adapter provides PostgreSQL persistence for tracking example data
/// seed runs using Diesel ORM with async support. It requires a configured
/// `DbPool` for connection management.
///
/// # Example
///
/// ```ignore
/// let pool = DbPool::new(config).await?;
/// let repo = DieselExampleDataRunsRepository::new(pool);
///
/// match repo.try_record_seed("mossy-owl", 12, 2026).await? {
///     SeedingResult::Applied => info!("Seeding users..."),
///     SeedingResult::AlreadySeeded => info!("Seed already applied"),
/// }
/// ```
#[derive(Clone)]
pub struct DieselExampleDataRunsRepository {
    pool: DbPool,
}

impl DieselExampleDataRunsRepository {
    /// Create a new repository with the given connection pool.
    pub fn new(pool: DbPool) -> Self {
        Self { pool }
    }
}

/// Map pool errors to domain persistence errors.
fn map_pool_error(error: PoolError) -> ExampleDataRunsError {
    match error {
        PoolError::Checkout { message } | PoolError::Build { message } => {
            ExampleDataRunsError::connection(message)
        }
    }
}

/// Map Diesel errors to domain persistence errors.
///
/// Only special-cases `NotFound` (for stable diagnostics) and `ClosedConnection`
/// (for connection vs query distinction). All other errors map to Query variant.
fn map_diesel_error(error: diesel::result::Error) -> ExampleDataRunsError {
    use diesel::result::{DatabaseErrorKind, Error as DieselError};

    debug!(?error, "diesel operation failed");

    match error {
        DieselError::NotFound => ExampleDataRunsError::query("record not found"),
        DieselError::DatabaseError(DatabaseErrorKind::ClosedConnection, info) => {
            ExampleDataRunsError::connection(info.message().to_owned())
        }
        DieselError::DatabaseError(_, info) => {
            ExampleDataRunsError::query(info.message().to_owned())
        }
        _ => ExampleDataRunsError::query("database error"),
    }
}

#[async_trait]
impl ExampleDataRunsRepository for DieselExampleDataRunsRepository {
    async fn try_record_seed(
        &self,
        seed_key: &str,
        user_count: i32,
        seed: i64,
    ) -> Result<SeedingResult, ExampleDataRunsError> {
        let mut conn = self.pool.get().await.map_err(map_pool_error)?;

        let new_row = NewExampleDataRunRow {
            seed_key,
            user_count,
            seed,
        };

        // INSERT ... ON CONFLICT DO NOTHING returns 0 rows affected if the key
        // already exists, 1 row if inserted.
        let rows_affected = diesel::insert_into(example_data_runs::table)
            .values(&new_row)
            .on_conflict(example_data_runs::seed_key)
            .do_nothing()
            .execute(&mut conn)
            .await
            .map_err(map_diesel_error)?;

        if rows_affected > 0 {
            Ok(SeedingResult::Applied)
        } else {
            Ok(SeedingResult::AlreadySeeded)
        }
    }

    async fn is_seeded(&self, seed_key: &str) -> Result<bool, ExampleDataRunsError> {
        let mut conn = self.pool.get().await.map_err(map_pool_error)?;

        let exists = diesel::select(diesel::dsl::exists(
            example_data_runs::table.filter(example_data_runs::seed_key.eq(seed_key)),
        ))
        .get_result(&mut conn)
        .await
        .map_err(map_diesel_error)?;

        Ok(exists)
    }
}

#[cfg(test)]
mod tests {
    //! Regression coverage for this module.
    use super::*;
    use rstest::rstest;

    #[rstest]
    fn pool_error_maps_to_connection_error() {
        let pool_err = PoolError::checkout("connection refused");
        let persistence_err = map_pool_error(pool_err);

        assert!(matches!(
            persistence_err,
            ExampleDataRunsError::Connection { .. }
        ));
        assert!(
            persistence_err.to_string().contains("connection refused"),
            "preserve useful diagnostics"
        );
    }

    #[rstest]
    fn diesel_error_maps_to_query_error() {
        let diesel_err = diesel::result::Error::NotFound;
        let persistence_err = map_diesel_error(diesel_err);

        assert!(matches!(
            persistence_err,
            ExampleDataRunsError::Query { .. }
        ));
        assert!(
            persistence_err.to_string().contains("record not found"),
            "preserve stable, user-facing diagnostics"
        );
    }
}
